== Introduction

Boost.HierarchicalEnum is a library that allows you to add a tree-like relation on the enumerators of a C++ enum.
Once you have defined a HierarchicalEnum, you can use this library to aswers questions like "Is A a descendant of B?" or "What is the nearest common ancester of A and B?"

Important note: this library is <em>candidate</em> to become part of <a>Boost</a>. This documentation and the code are written as if it was already in Boost, only to ease the peer review process, not to pretend that the library has already been accepted.

== Quick start

First define your HierarchicalEnum:

BOOST_HIERARCHICAL_ENUM(
    MovingState,
    (( Still, DEF(), (Laying)(Siting) ))
    (( Laying, DEF(), BOOST_PP_SEQ_NIL ))
    (( Siting, DEF(), BOOST_PP_SEQ_NIL ))
    (( Moving, DEF(), (Walking)(Swimming) ))
    (( Walking, DEF( ), (Running) ))
    (( Running, DEF(), BOOST_PP_SEQ_NIL ))
    (( Swimming, DEF(), BOOST_PP_SEQ_NIL ))
)

This defines a C++ enum named MovingState, and some template specializations to let you use the <a>Boost.HierarchicalEnum functions</a>.
The relationships between the enumerators are as shown in this graph:

<img src="Documentation.png"/>

Now, you can declare variables of type MovingState:

MovingState a = Running;
MovingState b = Swimming;
MovingState c = Still;
MovingState d = Moving;

You can then query the library about relationships between those variables.

namespace bhe = boost::hierarchical_enum;
bool s = bhe::is_descendant_of( a, c ) // false
bool t = bhe::is_ascendant_of( d, b ) // true
MovingState u = bhe::first_common_ascendant_of( a, d ) // Moving

There are also compile-time meta-functions:
bhe::is_ascendant_of< Running_c, Moving_c >::type // boost::mpl::false_
bhe::is_child_of< Running_c, Walking_c >::type // boost::mpl::true_
bhe::children_of< Moving_c >::type // boost::mpl::vector_< Walking_c, Swimming_c >

== Misclaneous notes

The current implementation of Boost.HierarchicalEnum is such that all results are pre-computed at compile-time with help of Boost.Mpl, and that run-time versions of the functions are as efficient as a simple switch on the argument, then return a constant.
The trade-off is that compilation time can be quite long, especialy for HierarchicalEnums with many enumerators, due to many template instanciations.
The trick is to encapsulate the calls to this library in your own functions, which are compiled only once in one given translation unit.
It is anyway a good idea to encapsulate this library into functions with names significant for your application domain.
A positive side-effect is that it narrows the wide interface of the library to only the functions which are meaningfull to you.

// MovingState.hpp
#include <boost/hierarchical_enum.hpp>

BOOST_HIERARCHICAL_ENUM( MovingState, ... )
bool isMoving( MovingState );

// MovingState.cpp
#include "MovingState.hpp"

namespace bhe = boost::hierarchical_enum;

bool isMoving( MovingState m ) {
    return bhe::is_descendant_of< Moving >( m );
}

This library is candidate to become part of <a>Boost</a>. As such, it's implementation <em>and</em> interface will be subject to as many changes as required by the peer review process.
In any case, the core functionalities will remain, so you are likely to be able to use the next versions, provided that you have encapsulated the calls to Boost.HierarchicalEnum.

As the author of this library, I would be glad to have any kind of feedback from your experience with it.
Be it "it sucks", "it's wonderful", or anything in the middle, with or without detailed explaination of why you think so,
I would be very greatfull if you took time to write a mail, either to the Boost mailing list or to my personnal address. (Prefer the mailing list for detailed critisisms that would help the review process)
Do not hesitate to critisize the documentation, the interface, the implementation and even my english language, since it's not my mother thong. These are all subjects to improvments.

== Reference

=== Definition of a HierarchicalEnum

==== Simple case

BOOST_HIERARCHICAL_ENUM( EnumName, Enumerators )
where:
    EnumName is the name of the enum t be declared
    Enumerators is a Boost.Preprocessor Sequence (Enumerator1)(Value2)...(ValueN)
    ValueI is a Boost.Preprocessor Tuple ( ValueName, 

==== Namespaces

Unfortunately, the current implementation of those macros define some template specializations that must live in the ::boost namespace.
This doesn't allow you to define a HierarchicalEnum inside your own namespace.
To define a HierarchicalEnum inside a namespace, you have to use:

BOOST_HIERARCHICAL_ENUM_NS( Namespaces, EnumName, Values )
where:
    Namespaces is the Boost.Preprocessor Sequence of the namespaces where the HierarchicalEnum must be declared, from the outer to the inner one.
    EnumName is as for BOOST_HIERARCHICAL_ENUM
    Values is as for BOOST_HIERARCHICAL_ENUM

=== Queries about a HierarchicalEnum

==== Run-time, compile-time and mixed-time

Each function comes in two versions: the classic run-time version, whose arguments are instances of the enum, and the template compile-time version, which is in fact a metafunction.
Additionally, functions taking two or more arguments have mixed-time versions, which take some of their arguments as run-time arguments, and the other arguments as template arguments.

==== Predicates, single elements and collections

There are three return types for the functions of the library: boolean, (optional) single element, and collection.

The run-time and mixed-time versions of functions returning a boolean return a bool.
The compile-time version returns boost::mpl::true_ or boost::mpl::false_.

==== Functions definitions

===== is_child_of
A is_child_of B iif A is listed in B's children list

===== children_of
children_of A is the set os Bs such that B is_child_of A

===== is_strict_descendant_of
A is_strict_descendant_of B iif A is_child_of B or if there is a C such that A is_child_of C and C is_strict_descendant_of B

===== is_descendant_of
A is_descendant_of B iif A == B or A is_strict_descendant_of B

===== is_father_of
A is_father_of B iif B is_child_of A

===== has_father
A has_father iif A is in a children list

===== father_of
Only valid if A has_father. Overwise, the run-time version will throw, and the compile-time version will not compile.
father_of A is the B such that B is_father_of A

===== is_ascendant_of
A is_ascendant_of B iif B is_descendant_of A

===== is_strict_ascendant_of
A is_strict_ascendant_of B iif B is_strict_descendant_of A

===== common_ascendants_of
common_ascendants_of A and B is the set of Cs such that C is_ascendant_of A and C is_ascendant_of B

===== strict_common_ascendants_of
strict_common_ascendants_of A and B is the set of Cs such that C is_strict_ascendant_of A and C is_strict_ascendant_of B

===== have_common_ascendant
A and B have_common_ascendant iif common_ascendants_of A and B is not empty

===== have_strict_common_ascendant
A and B have_strict_common_ascendant iif strict_common_ascendants_of A and B is not empty

===== first_common_ascendant_of
first_common_ascendant_of A and B is the C in common_ascendants_of A and B such that for any D in common_ascendants_of A and B, D is_ascendant_of C

===== first_strict_common_ascendant_of
first_strict_common_ascendant_of A and B is the C in strict_common_ascendants_of A and B such that for any D in strict_common_ascendants_of A and B, D is_ascendant_of C
