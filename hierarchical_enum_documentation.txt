== Introduction

Beast.HierarchicalEnum is a library that allows you to add a tree-like relation on the enumerators of a C++ enum.
Once you have defined a HierarchicalEnum, you can use this library to aswers questions like "Is A a descendant of B?" or "What is the nearest common ancester of A and B?"

== Quick start

First define your HierarchicalEnum:

BEAST_HIERARCHICAL_ENUM( MovingState, ... )

This defines a C++ enum named MovingState, and some template specializations to let you use the <a>Beast.HierarchicalEnum functions</a>.
The relationships between the enumerators are as shown in this graph:

digraph D {
    Walking -> Moving;
    Swimming -> Moving;
    Laying -> Still;
    Siting -> Still;
    ...
}

Now, you can declare variables of type MovingState:

MovingState a = Running;
MovingState b = Swimming;
MovingState c = Still;
MovingState d = Moving;

You can then query the library about relationships between those variables.

namespace bhe = beast::hierarchical_enum;
bool s = bhe::is_descendant_of( a, c ) // false
bool t = bhe::is_ascendant_of( d, b ) // true
MovingState u = bhe::first_common_ascendant_of( a, d ) // Moving

There are also compile-time meta-functions:
bhe::is_ascendant_of< Running_c, Moving_c >::type // boost::mpl::false_
bhe::is_child_of< Running_c, Walking_c >::type // boost::mpl::true_
bhe::children_of< Moving_c >::type // boost::mpl::vector_< Walking_c, Swimming_c >

== Misclaneous notes

The current implementation of Beast.HierarchicalEnum is such that all results are pre-computed at compile-time with help of Boost.Mpl,
and that run-time versions of the functions are as efficient as a simple switch on the argument, then return a constant.
The trade-off is that compilation time can be quite long, especialy for HierarchicalEnums with many enumerators, due to many template instanciations.
The trick is to encapsulate the calls to this library in your own functions, which are compiled only once in one givent translation unit.
It is often a good idea to encapsulate this library into functions with names significant for your application domain.
A positive side-effect is that it narrows the wide interface of the library to only the functions which are meaningfull to you.

// MovingState.hpp
#include <beast/hierarchical_enum.hpp>

BEAST_HIERARCHICAL_ENUM( MovingState, ... )
bool isMoving( MovingState );

// MovingState.cpp
#include "MovingState.hpp"

bool isMoving( MovingState m ) {
    return bhe::is_descendant_of< Moving >( m );
}

This library is candidate to become part of <a>Boost</a>. As such, it's implementation /and/ interface will be subject to as many changes as required by the peer review process.
An obvious point is that if it gets through the process, any occurence of beast, Beast and BEAST will be replaced by boost, Boost, and BOOST.
Anyway the core functionalities will remain, so you are likely to be able to use the next versions, provided that you have encapsulated the calls to Beast.HierarchicalEnum in your own functions.

As the author of this library, I would be glad to have any kind of feedback from your experience with it.
Be it "it sucks", "it's wonderful", or anything in the middle, with or without detailed explaination of why you think so,
I would be very greatfull if you took time to write a mail, either to the Boost mailing list or to my personnal address. (Prefer the mailing list for detailed critisisms that would help the review process)
Do not hesitate to critisize the documentation, the interface, the implementation and evne my english language, since it's not my mother thong. These are all subjects to improvments.

== Reference

=== Definition of a HierarchicalEnum

==== Simple case

BEAST_HIERARCHICAL_ENUM

==== Specify the values

If you want to give specific values to the enumerators of your enum, please use:

BEAST_HIERARCHICAL_ENUM_WITH_VALUES

==== Namespaces

Unfortunately, the current implementation of those macros define some template specializations that must live in the ::beast namespace.
This doesn't allow you to define a HierarchicalEnum inside your own namespace.
To define a HierarchicalEnum inside a namespace, you have to use:

BEAST_HIERARCHICAL_ENUM_NS
BEAST_HIERARCHICAL_ENUM_NS_WITH_VALUES

=== Queries about a HierarchicalEnum

==== Run-time, compile-time and mixed-time

Each function comes in two versions: the classic run-time version, whose arguments are instances of the enum, and the template compile-time version, which is in fact a metafunction.
Additionally, functions taking two or more arguments have mixed-time versions, which take some of their arguments as run-time arguments, and the other arguments as template arguments.

==== Predicates, single elements and collections

There are three return types for the functions of the library: boolean, (optional) single element, and collection.

The run-time and mixed-time versions of functions returning a boolean return a bool.
The compile-time version returns boost::mpl::true_ or boost::mpl::false_.

==== Functions definitions

===== is_child_of
A is_child_of B iif A is listed in B's children list

===== children_of
children_of A is the set os Bs such that B is_child_of A

===== is_strict_descendant_of
A is_strict_descendant_of B iif A is_child_of B or if there is a C such that A is_child_of C and C is_strict_descendant_of B

===== is_descendant_of
A is_descendant_of B iif A == B or A is_strict_descendant_of B

===== is_father_of
A is_father_of B iif B is_child_of A

===== has_father
A has_father iif A is in a children list

===== father_of
Only valid if A has_father. Overwise, the run-time version will throw, and the compile-time version will not compile.
father_of A is the B such that B is_father_of A

===== is_ascendant_of
A is_ascendant_of B iif B is_descendant_of A

===== is_strict_ascendant_of
A is_strict_ascendant_of B iif B is_strict_descendant_of A

===== common_ascendants_of
common_ascendants_of A and B is the set of Cs such that C is_ascendant_of A and C is_ascendant_of B

===== strict_common_ascendants_of
strict_common_ascendants_of A and B is the set of Cs such that C is_strict_ascendant_of A and C is_strict_ascendant_of B

===== have_common_ascendant
A and B have_common_ascendant iif common_ascendants_of A and B is not empty

===== have_strict_common_ascendant
A and B have_strict_common_ascendant iif strict_common_ascendants_of A and B is not empty

===== first_common_ascendant_of
first_common_ascendant_of A and B is the C in common_ascendants_of A and B such that for any D in common_ascendants_of A and B, D is_ascendant_of C

===== first_strict_common_ascendant_of
first_strict_common_ascendant_of A and B is the C in strict_common_ascendants_of A and B such that for any D in strict_common_ascendants_of A and B, D is_ascendant_of C


























